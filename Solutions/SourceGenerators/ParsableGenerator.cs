using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System.Collections.Immutable;
using System.Text;
using System.Linq;

namespace AdventOfCode.SourceGenerators;

/// <summary>
/// Source generator that automatically generates IParsable&lt;T&gt; boilerplate methods
/// for types marked with [GenerateIParsable] attribute.
/// </summary>
[Generator]
public class ParsableGenerator : IIncrementalGenerator
{
	private const string AttributeName = "AdventOfCode.SourceGenerators.GenerateIParsableAttribute";

	private const string AttributeSource = """
		// <auto-generated/>
		#nullable enable

		namespace AdventOfCode.SourceGenerators;

		/// <summary>
		/// Marks a type for automatic generation of IParsable&lt;T&gt; boilerplate methods.
		/// The type must implement Parse(string s, IFormatProvider? provider).
		/// The generator will create Parse(string s) and TryParse(...) methods automatically.
		/// The generator will add the IParsable&lt;T&gt; interface to the type as well.
		/// </summary>
		[global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
		internal sealed class GenerateIParsableAttribute : global::System.Attribute
		{
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Generate the attribute itself so the generator is self-contained
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"GenerateIParsableAttribute.g.cs",
			SourceText.From(AttributeSource, Encoding.UTF8)));

		// Register syntax receiver to find types with [GenerateParsable] attribute
		IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
				transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
			.Where(static m => m is not null)!;

		// Combine with compilation
		IncrementalValueProvider<(Compilation, ImmutableArray<TypeDeclarationSyntax>)> compilationAndTypes
			= context.CompilationProvider.Combine(typeDeclarations.Collect());

		// Generate source
		context.RegisterSourceOutput(compilationAndTypes,
			static (spc, source) => Execute(source.Item1, source.Item2, spc));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };

	private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		TypeDeclarationSyntax typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeListSyntax in typeDeclarationSyntax.AttributeLists) {
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
				if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) {
					continue;
				}

				INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
				string fullName = attributeContainingTypeSymbol.ToDisplayString();

				if (fullName == AttributeName) {
					return typeDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
	{
		if (types.IsDefaultOrEmpty) {
			return;
		}

		foreach (TypeDeclarationSyntax typeDeclaration in types.Distinct()) {
			context.CancellationToken.ThrowIfCancellationRequested();

			SemanticModel semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(typeDeclaration) is not INamedTypeSymbol typeSymbol) {
				continue;
			}

			string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
			string typeName = typeSymbol.Name;

			// Determine the full type keyword(s) - handles "record struct", "record class", "record", "class", "struct"
			string typeKeyword = GetTypeKeyword(typeSymbol);

			// Get containing types (for nested types)
			List<(string Name, string Keyword)> containingTypes = [];
			INamedTypeSymbol? containingType = typeSymbol.ContainingType;
			INamedTypeSymbol containingTypeSymbol = default!;
			while (containingType is not null) {
				string containingKeyword = containingType.TypeKind switch
				{
					TypeKind.Class => "partial class",
					TypeKind.Struct => "partial struct",
					_ => "partial class"
				};

				if (containingType.TypeKind is TypeKind.Class or TypeKind.Struct) {
					containingTypeSymbol = containingType;
				}

				containingTypes.Insert(0, (containingType.Name, containingKeyword));
				containingType = containingType.ContainingType;
			}

			// Get constructor parameter types
			string[] constructorParametersList = [.. GetRecordParameterTypes(typeSymbol)];

			// Check which methods already exist
			bool hasParseMethod = HasParseStringMethod(typeSymbol);
			bool hasParseStringWithProviderMethod = HasParseStringWithProviderMethod(typeSymbol);
			bool hasTryParseMethod = HasTryParseMethod(typeSymbol);
			bool implementsIParsable = ImplementsIParsable(typeSymbol);

			// Skip generation if both methods already exist
			//if (hasParseMethod && hasParseStringWithProviderMethod && hasTryParseMethod && implementsIParsable) {
			//	continue;
			//}

			string source = GenerateSource(namespaceName, typeName, typeKeyword, containingTypes, constructorParametersList,
				!hasParseMethod, !hasParseStringWithProviderMethod, !hasTryParseMethod, !implementsIParsable);

			// Use full type path for unique filename
			string fileName = containingTypes.Count > 0
				? $"{string.Join(".", containingTypes.Select(t => t.Name))}.{typeName}.g.cs"
				: $"{typeName}.g.cs";

			context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
		}
	}

	private static string GetTypeKeyword(INamedTypeSymbol typeSymbol)
	{
		// Check if it's a record type (record class or record struct)
		bool isRecord = typeSymbol.IsRecord;
		bool isStruct = typeSymbol.TypeKind == TypeKind.Struct;
		bool isClass = typeSymbol.TypeKind == TypeKind.Class;

		return (isRecord, isStruct, isClass) switch
		{
			(true, true, _) => "record struct",
			(true, _, true) => "record class",
			(true, _, _) => "record",
			(false, true, _) => "struct",
			_ => "class"
		};
	}

	// Get the types of the properties in the constructor of the containing class/struct/record
	private static IEnumerable<string> GetRecordParameterTypes(INamedTypeSymbol typeSymbol)
	{
		// return record properties needed for new RecordType(param1, param2)
		if (typeSymbol is null || !typeSymbol.IsRecord) {
			return [];
		}

		// For records, look for the primary constructor and get its parameter types
		IMethodSymbol? primaryConstructor = typeSymbol.Constructors
			.FirstOrDefault(c => c.Parameters.Length > 0 && !c.IsImplicitlyDeclared);

		if (primaryConstructor is not null) {
			return primaryConstructor.Parameters
				.Select(p => p.Type.ToDisplayString());
		}

		// Fallback: get public properties (works for positional records)
		return typeSymbol.GetMembers()
			.OfType<IPropertySymbol>()
			.Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
			.Select(p => p.Type.ToDisplayString());
	}

	private static string GenerateSource(string namespaceName, string typeName, string typeKeyword,
		List<(string Name, string Keyword)> containingTypes, string[] constructorParametersList, bool generateParse, bool generateParseWithProvider, bool generateTryParse, bool addIParsableInterface)
	{
		// Build opening declarations for nested types
		StringBuilder containingTypesOpen = new();
		StringBuilder containingTypesClose = new();
		int baseIndent = 0;

		foreach ((string name, string keyword) in containingTypes) {
			_ = containingTypesOpen.AppendLine($"{GetIndent(baseIndent)}{keyword} {name}");
			_ = containingTypesOpen.AppendLine($"{GetIndent(baseIndent)}{{");
			_ = containingTypesClose.Insert(0, $"{GetIndent(baseIndent)}}}");
			_ = containingTypesOpen.AppendLine();
			baseIndent++;
		}

		string indent = GetIndent(baseIndent);
		string interfaceDeclaration = addIParsableInterface ? $" : IParsable<{typeName}>" : "";

		string parseMethod = generateParse && generateParseWithProvider
			? $$"""
				{{indent}}	public static {{typeName}} Parse(string s)
				{{indent}}	{
				{{indent}}	{{CreateNewFromConstructorParamaters(constructorParametersList)}};
				{{indent}}	}
				"""
			: generateParse && !generateParseWithProvider
				? $$"""
					{{indent}}	public static {{typeName}} Parse(string s) => {{typeName}}.Parse(s, null);
					"""
				: "";

		string parseMethodWithProvider = generateParseWithProvider
			? $$"""
				{{indent}}	public static {{typeName}} Parse(string s, IFormatProvider? provider) => {{typeName}}.Parse(s);
				"""
			: "";

		string tryParseMethod = generateTryParse
			? $$"""
				{{indent}}	public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{typeName}} result)
				{{indent}}	{
				{{indent}}		if (string.IsNullOrWhiteSpace(s))
				{{indent}}		{
				{{indent}}			result = default;
				{{indent}}			return false;
				{{indent}}		}

				{{indent}}		try
				{{indent}}		{
				{{indent}}			result = {{typeName}}.Parse(s, provider);
				{{indent}}			return true;
				{{indent}}		}
				{{indent}}		catch
				{{indent}}		{
				{{indent}}			result = default;
				{{indent}}			return false;
				{{indent}}		}
				{{indent}}	}
				"""
			: "";

		string parameterTypesComment = constructorParametersList.Length > 0
			? $$"""{{indent}}	// Parameters: {{string.Join(", ", constructorParametersList)}}"""
			: "";

		return $$"""
			// <auto-generated/>
			#nullable enable

			using System.Diagnostics.CodeAnalysis;

			namespace {{namespaceName}};

			{{containingTypesOpen}}{{indent}}partial {{typeKeyword}} {{typeName}}{{interfaceDeclaration}}
			{{indent}}{
			{{parameterTypesComment}}
			{{parseMethod}}
			{{parseMethodWithProvider}}
			{{tryParseMethod}}
			{{indent}}}
			{{containingTypesClose}}
			""";
	}

	private static string CreateNewFromConstructorParamaters(string[] constructorParametersList)
	{
		if (constructorParametersList == null || constructorParametersList.Length == 0) {
			return "\treturn new()";
		}

		List<string> parameters = [];
		foreach (string parameterType in constructorParametersList) {
			string parameter = parameterType switch {
				"string" => "s",
				_ => $"{parameterType}.Parse(s)"
			};
			parameters.Add(parameter);
		}

		if (constructorParametersList.Length == 1) {
			return $"\treturn new({parameters[0]})";
		}



		StringBuilder sb = new();
		_ = sb.Append("\treturn new(");
		_ = sb.Append(string.Join(", ", parameters.Select(p => $"{p}")));

		_ = sb.Append(")");
		return sb.ToString();
	}
	private static string GetIndent(int level) => new('\t', level);

	private static bool HasParseStringMethod(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.GetMembers("Parse")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic &&
				 m.Parameters.Length == 1 &&
				 m.Parameters[0].Type.SpecialType == SpecialType.System_String);
	}

	private static bool HasParseStringWithProviderMethod(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.GetMembers("Parse")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic &&
				 m.Parameters.Length == 2 &&
				 m.Parameters[0].Type.SpecialType == SpecialType.System_String);
	}

	private static bool HasTryParseMethod(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.GetMembers("TryParse")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic &&
				 m.Parameters.Length == 3 &&
				 m.Parameters[0].Type.SpecialType == SpecialType.System_String &&
				 m.Parameters[2].RefKind == RefKind.Out);
	}

	private static bool ImplementsIParsable(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.AllInterfaces.Any(i =>
			i.Name == "IParsable" &&
			i.IsGenericType &&
			i.TypeArguments.Length == 1);
	}
}
