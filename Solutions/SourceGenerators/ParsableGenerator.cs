using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using System.Collections.Immutable;
using System.Text;
using System.Linq;

namespace AdventOfCode.SourceGenerators;

/// <summary>
/// Source generator that automatically generates IParsable&lt;T&gt; boilerplate methods
/// for types marked with [GenerateIParsable] attribute.
/// </summary>
[Generator]
public class ParsableGenerator : IIncrementalGenerator
{
	private const string AttributeName = "AdventOfCode.SourceGenerators.GenerateIParsableAttribute";

	private const string AttributeSource = """
		// <auto-generated/>
		#nullable enable

		namespace AdventOfCode.SourceGenerators;

		/// <summary>
		/// Marks a type for automatic generation of IParsable&lt;T&gt; boilerplate methods.
		/// The type must implement Parse(string s, IFormatProvider? provider).
		/// The generator will create Parse(string s) and TryParse(...) methods automatically.
		/// The generator will add the IParsable&lt;T&gt; interface to the type as well.
		/// </summary>
		[global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
		internal sealed class GenerateIParsableAttribute : global::System.Attribute
		{
			/// <summary>
			/// Gets or sets the characters to use for splitting the input string when multiple constructor parameters exist.
			/// Default is ' ' and ','.
			/// </summary>
			public string SplitChars { get; set; } = " ,";

			/// <summary>
			/// Gets or sets the regex pattern to use for splitting the input string.
			/// If specified, this takes precedence over SplitChars.
			/// </summary>
			public string? SplitPattern { get; set; }

			/// <summary>
			/// Gets or sets whether to remove empty entries after splitting.
			/// Default is true.
			/// </summary>
			public bool RemoveEmptyEntries { get; set; } = true;
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Generate the attribute itself so the generator is self-contained
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"GenerateIParsableAttribute.g.cs",
			SourceText.From(AttributeSource, Encoding.UTF8)));

		// Register syntax receiver to find types with [GenerateParsable] attribute
		IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
				transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
			.Where(static m => m is not null)!;

		// Combine with compilation
		IncrementalValueProvider<(Compilation, ImmutableArray<TypeDeclarationSyntax>)> compilationAndTypes
			= context.CompilationProvider.Combine(typeDeclarations.Collect());

		// Generate source
		context.RegisterSourceOutput(compilationAndTypes,
			static (spc, source) => Execute(source.Item1, source.Item2, spc));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };

	private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		TypeDeclarationSyntax typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeListSyntax in typeDeclarationSyntax.AttributeLists) {
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
				if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) {
					continue;
				}

				INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
				string fullName = attributeContainingTypeSymbol.ToDisplayString();

				if (fullName == AttributeName) {
					return typeDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
	{
		if (types.IsDefaultOrEmpty) {
			return;
		}

		foreach (TypeDeclarationSyntax typeDeclaration in types.Distinct()) {
			context.CancellationToken.ThrowIfCancellationRequested();

			SemanticModel semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(typeDeclaration) is not INamedTypeSymbol typeSymbol) {
				continue;
			}

			string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
			string typeName = typeSymbol.Name;

			// Extract split configuration from attribute
			SplitConfiguration splitConfig = GetSplitConfiguration(typeDeclaration, semanticModel);

			// Determine the full type keyword(s) - handles "record struct", "record class", "record", "class", "struct"
			string typeKeyword = GetTypeKeyword(typeSymbol);

			// Get containing types (for nested types)
			List<(string Name, string Keyword)> containingTypes = [];
			INamedTypeSymbol? containingType = typeSymbol.ContainingType;
			INamedTypeSymbol containingTypeSymbol = default!;
			while (containingType is not null) {
				string containingKeyword = containingType.TypeKind switch
				{
					TypeKind.Class => "partial class",
					TypeKind.Struct => "partial struct",
					_ => "partial class"
				};

				if (containingType.TypeKind is TypeKind.Class or TypeKind.Struct) {
					containingTypeSymbol = containingType;
				}

				containingTypes.Insert(0, (containingType.Name, containingKeyword));
				containingType = containingType.ContainingType;
			}

			// Get constructor parameter types
			string[] constructorParametersList = [.. GetRecordParameterTypes(typeSymbol)];

			// Check which methods already exist
			bool hasParseMethod = HasParseStringMethod(typeSymbol);
			bool hasParseStringWithProviderMethod = HasParseStringWithProviderMethod(typeSymbol);
			bool hasTryParseMethod = HasTryParseMethod(typeSymbol);
			bool implementsIParsable = ImplementsIParsable(typeSymbol);

			// Skip generation if both methods already exist
			//if (hasParseMethod && hasParseStringWithProviderMethod && hasTryParseMethod && implementsIParsable) {
			//	continue;
			//}

			string source = GenerateSource(namespaceName, typeName, typeKeyword, containingTypes, constructorParametersList,
				!hasParseMethod, !hasParseStringWithProviderMethod, !hasTryParseMethod, !implementsIParsable, splitConfig);

			// Use full type path for unique filename
			string fileName = containingTypes.Count > 0
				? $"{string.Join(".", containingTypes.Select(t => t.Name))}.{typeName}.g.cs"
				: $"{typeName}.g.cs";

			context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
		}
	}

	private static string GetTypeKeyword(INamedTypeSymbol typeSymbol)
	{
		// Check if it's a record type (record class or record struct)
		bool isRecord = typeSymbol.IsRecord;
		bool isStruct = typeSymbol.TypeKind == TypeKind.Struct;
		bool isClass = typeSymbol.TypeKind == TypeKind.Class;

		return (isRecord, isStruct, isClass) switch
		{
			(true, true, _) => "record struct",
			(true, _, true) => "record class",
			(true, _, _) => "record",
			(false, true, _) => "struct",
			_ => "class"
		};
	}

	private class SplitConfiguration(string splitChars, string? splitPattern, bool removeEmptyEntries)
	{
		public string SplitChars { get; } = splitChars;
		public string? SplitPattern { get; } = splitPattern;
		public bool RemoveEmptyEntries { get; } = removeEmptyEntries;
	}

	private static SplitConfiguration GetSplitConfiguration(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel)
	{
		string splitChars = " ,";
		string? splitPattern = null;
		bool removeEmptyEntries = true;

		foreach (AttributeListSyntax attributeListSyntax in typeDeclaration.AttributeLists) {
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes) {
				if (semanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) {
					continue;
				}

				if (attributeSymbol.ContainingType.ToDisplayString() != AttributeName) {
					continue;
				}

				// Extract attribute arguments
				if (attributeSyntax.ArgumentList is null) {
					continue;
				}

				foreach (AttributeArgumentSyntax argument in attributeSyntax.ArgumentList.Arguments) {
					string? propertyName = argument.NameEquals?.Name.Identifier.Text;
					if (propertyName is null) {
						continue;
					}

					if (propertyName == "SplitChars" && argument.Expression is LiteralExpressionSyntax splitCharsLiteral) {
						splitChars = splitCharsLiteral.Token.ValueText;
					} else if (propertyName == "SplitPattern" && argument.Expression is LiteralExpressionSyntax splitPatternLiteral) {
						splitPattern = splitPatternLiteral.Token.ValueText;
					} else if (propertyName == "RemoveEmptyEntries" && argument.Expression is LiteralExpressionSyntax removeEmptyLiteral) {
						if (bool.TryParse(removeEmptyLiteral.Token.ValueText, out bool value)) {
							removeEmptyEntries = value;
						}
					}
				}
			}
		}

		return new SplitConfiguration(splitChars, splitPattern, removeEmptyEntries);
	}

	// Get the types of the properties in the constructor of the containing class/struct/record
	private static IEnumerable<string> GetRecordParameterTypes(INamedTypeSymbol typeSymbol)
	{
		// return record properties needed for new RecordType(param1, param2)
		if (typeSymbol is null || !typeSymbol.IsRecord) {
			return [];
		}

		// For records, look for the primary constructor and get its parameter types
		IMethodSymbol? primaryConstructor = typeSymbol.Constructors
			.FirstOrDefault(c => c.Parameters.Length > 0 && !c.IsImplicitlyDeclared);

		if (primaryConstructor is not null) {
			return primaryConstructor.Parameters
				.Select(p => p.Type.ToDisplayString());
		}

		// Fallback: get public properties (works for positional records)
		return typeSymbol.GetMembers()
			.OfType<IPropertySymbol>()
			.Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
			.Select(p => p.Type.ToDisplayString());
	}

	private static string GenerateSource(string namespaceName, string typeName, string typeKeyword,
		List<(string Name, string Keyword)> containingTypes, string[] constructorParametersList, bool generateParse, bool generateParseWithProvider, bool generateTryParse, bool addIParsableInterface, SplitConfiguration splitConfig)
	{
		// Build opening declarations for nested types
		StringBuilder containingTypesOpen = new();
		StringBuilder containingTypesClose = new();
		int baseIndent = 0;

		foreach ((string name, string keyword) in containingTypes) {
			_ = containingTypesOpen.AppendLine($"{GetIndent(baseIndent)}{keyword} {name}");
			_ = containingTypesOpen.AppendLine($"{GetIndent(baseIndent)}{{");
			_ = containingTypesClose.Insert(0, $"{GetIndent(baseIndent)}}}");
			_ = containingTypesOpen.AppendLine();
			baseIndent++;
		}

		string indent = GetIndent(baseIndent);
		string interfaceDeclaration = addIParsableInterface ? $" : IParsable<{typeName}>" : "";

		string parseMethod = generateParse && generateParseWithProvider
			? $$"""
				{{indent}}	public static {{typeName}} Parse(string s)
				{{indent}}	{
				{{CreateNewFromConstructorParameters(typeName, constructorParametersList, splitConfig, indent)}}
				{{indent}}	}
				"""
			: generateParse && !generateParseWithProvider
				? $$"""
					{{indent}}	public static {{typeName}} Parse(string s) => {{typeName}}.Parse(s, null);
					"""
				: "";

		string parseMethodWithProvider = generateParseWithProvider
			? $$"""
				{{indent}}	public static {{typeName}} Parse(string s, IFormatProvider? provider) => {{typeName}}.Parse(s);
				"""
			: "";

		string tryParseMethod = generateTryParse
			? $$"""
				{{indent}}	public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{typeName}} result)
				{{indent}}	{
				{{indent}}		if (string.IsNullOrWhiteSpace(s))
				{{indent}}		{
				{{indent}}			result = default;
				{{indent}}			return false;
				{{indent}}		}

				{{indent}}		try
				{{indent}}		{
				{{indent}}			result = {{typeName}}.Parse(s, provider);
				{{indent}}			return true;
				{{indent}}		}
				{{indent}}		catch
				{{indent}}		{
				{{indent}}			result = default;
				{{indent}}			return false;
				{{indent}}		}
				{{indent}}	}
				"""
			: "";

		string parameterTypesComment = constructorParametersList.Length > 0
			? $$"""{{indent}}	// Parameters: {{string.Join(", ", constructorParametersList)}}"""
			: "";

		// Add necessary using statements based on split configuration and parameter types
		bool needsRegex = !string.IsNullOrEmpty(splitConfig.SplitPattern);
		bool needsLinq = constructorParametersList.Length > 1 && needsRegex && splitConfig.RemoveEmptyEntries;

		// Check if any parameter is a collection type that needs LINQ
		foreach (string paramType in constructorParametersList) {
			if (IsCollectionType(paramType, out string? elementType)) {
				if (elementType != "string") {
					needsLinq = true;
				}
			}
		}

		string additionalUsings = "";
		if (needsRegex) {
			additionalUsings += "using System.Text.RegularExpressions;\n";
		}
		if (needsLinq) {
			additionalUsings += "using System.Linq;\n";
		}

		return $$"""
			// <auto-generated/>
			#nullable enable

			using System.Diagnostics.CodeAnalysis;
			{{additionalUsings}}
			namespace {{namespaceName}};

			{{containingTypesOpen}}{{indent}}partial {{typeKeyword}} {{typeName}}{{interfaceDeclaration}}
			{{indent}}{
			{{parameterTypesComment}}
			{{parseMethod}}
			{{parseMethodWithProvider}}
			{{tryParseMethod}}
			{{indent}}}
			{{containingTypesClose}}
			""";
	}

	private static string CreateNewFromConstructorParameters(string typeName, string[] constructorParametersList, SplitConfiguration splitConfig, string indent)
	{
		if (constructorParametersList == null || constructorParametersList.Length == 0) {
			return $"{indent}\t\treturn new();";
		}

		if (constructorParametersList.Length == 1) {
			string parameterType = constructorParametersList[0];

			// Check if it's a collection type
			if (IsCollectionType(parameterType, out string? elementType)) {
				return GenerateCollectionParsing(typeName, parameterType, elementType, splitConfig, indent);
			}

			// Simple single parameter
			string parameter = parameterType switch
			{
				"string" => "s",
				_ => $"{parameterType}.Parse(s)"
			};
			return $"{indent}\t\treturn new({parameter});";
		}

		// Multiple parameters - need to split the input string
		StringBuilder sb = new();

		// Generate split logic
		if (!string.IsNullOrEmpty(splitConfig.SplitPattern)) {
			// Use Regex.Split
			string options = splitConfig.RemoveEmptyEntries ? ", RegexOptions.None" : ", RegexOptions.None";
			_ = sb.AppendLine($"{indent}\t\tstring[] parts = Regex.Split(s, @\"{splitConfig.SplitPattern}\"{options});");
			if (splitConfig.RemoveEmptyEntries) {
				_ = sb.AppendLine($"{indent}\t\tparts = parts.Where(p => !string.IsNullOrWhiteSpace(p)).ToArray();");
			}
		} else {
			// Use string.Split with characters
			string splitCharsArray = string.Join(", ", splitConfig.SplitChars.Select(c => $"'{c}'"));
			string splitOptions = splitConfig.RemoveEmptyEntries
				? ", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries"
				: ", StringSplitOptions.TrimEntries";
			_ = sb.AppendLine($"{indent}\t\tstring[] parts = s.Split([{splitCharsArray}]{splitOptions});");
		}

		// Generate parameter parsing
		List<string> parameterExpressions = [];
		for (int i = 0; i < constructorParametersList.Length; i++) {
			string parameterType = constructorParametersList[i];
			string expression = parameterType switch
			{
				"string" => $"parts[{i}]",
				_ => $"{parameterType}.Parse(parts[{i}])"
			};
			parameterExpressions.Add(expression);
		}

		_ = sb.Append($"{indent}\t\treturn new {typeName}({string.Join(", ", parameterExpressions)});");
		return sb.ToString();
	}

	private static bool IsCollectionType(string typeString, out string? elementType)
	{
		elementType = null;

		// Check for array: T[]
		if (typeString.EndsWith("[]")) {
			elementType = typeString.Substring(0, typeString.Length - 2);
			return true;
		}

		// Check for List<T>
		if (typeString.StartsWith("List<") || typeString.StartsWith("System.Collections.Generic.List<")) {
			int startIndex = typeString.IndexOf('<') + 1;
			int endIndex = typeString.LastIndexOf('>');
			if (endIndex > startIndex) {
				elementType = typeString.Substring(startIndex, endIndex - startIndex);
				return true;
			}
		}

		// Check for IEnumerable<T>
		if (typeString.StartsWith("IEnumerable<") || typeString.StartsWith("System.Collections.Generic.IEnumerable<")) {
			int startIndex = typeString.IndexOf('<') + 1;
			int endIndex = typeString.LastIndexOf('>');
			if (endIndex > startIndex) {
				elementType = typeString.Substring(startIndex, endIndex - startIndex);
				return true;
			}
		}

		return false;
	}

	private static string GenerateCollectionParsing(string typeName, string parameterType, string elementType, SplitConfiguration splitConfig, string indent)
	{
		StringBuilder sb = new();

		// Generate split logic
		if (!string.IsNullOrEmpty(splitConfig.SplitPattern)) {
			// Use Regex.Split
			string options = splitConfig.RemoveEmptyEntries ? ", RegexOptions.None" : ", RegexOptions.None";
			_ = sb.AppendLine($"{indent}\t\tstring[] parts = Regex.Split(s, @\"{splitConfig.SplitPattern}\"{options});");
			if (splitConfig.RemoveEmptyEntries) {
				_ = sb.AppendLine($"{indent}\t\tparts = parts.Where(p => !string.IsNullOrWhiteSpace(p)).ToArray();");
			}
		} else {
			// Use string.Split with characters
			string splitCharsArray = string.Join(", ", splitConfig.SplitChars.Select(c => $"'{c}'"));
			string splitOptions = splitConfig.RemoveEmptyEntries
				? ", StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries"
				: ", StringSplitOptions.TrimEntries";
			_ = sb.AppendLine($"{indent}\t\tstring[] parts = s.Split([{splitCharsArray}]{splitOptions});");
		}

		// Generate element parsing based on element type
		string parseExpression = elementType switch
		{
			"string" => "parts",
			_ => $"parts.Select({elementType}.Parse)"
		};

		// Generate collection creation based on parameter type
		string collectionCreation;
		if (parameterType.EndsWith("[]")) {
			// Array type
			collectionCreation = elementType == "string" ? "parts" : parseExpression;
		} else if (parameterType.StartsWith("List<") || parameterType.StartsWith("System.Collections.Generic.List<")) {
			// List<T> type
			collectionCreation = elementType == "string" ? "[.. parts]" : $"[.. {parseExpression}]";
		} else {
			// IEnumerable<T> type
			collectionCreation = elementType == "string" ? "parts" : parseExpression;
		}

		_ = sb.Append($"{indent}\t\treturn new {typeName}({collectionCreation});");
		return sb.ToString();
	}

	private static string GetIndent(int level) => new('\t', level);

	private static bool HasParseStringMethod(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.GetMembers("Parse")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic &&
				 m.Parameters.Length == 1 &&
				 m.Parameters[0].Type.SpecialType == SpecialType.System_String);
	}

	private static bool HasParseStringWithProviderMethod(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.GetMembers("Parse")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic &&
				 m.Parameters.Length == 2 &&
				 m.Parameters[0].Type.SpecialType == SpecialType.System_String);
	}

	private static bool HasTryParseMethod(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.GetMembers("TryParse")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic &&
				 m.Parameters.Length == 3 &&
				 m.Parameters[0].Type.SpecialType == SpecialType.System_String &&
				 m.Parameters[2].RefKind == RefKind.Out);
	}

	private static bool ImplementsIParsable(INamedTypeSymbol typeSymbol)
	{
		return typeSymbol.AllInterfaces.Any(i =>
			i.Name == "IParsable" &&
			i.IsGenericType &&
			i.TypeArguments.Length == 1);
	}
}
