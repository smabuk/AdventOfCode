using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace AdventOfCode.SourceGenerators;

/// <summary>
/// Source generator that automatically generates IParsable&lt;T&gt; boilerplate methods
/// for types marked with [GenerateParsable] attribute.
/// </summary>
[Generator]
public class ParsableGenerator : IIncrementalGenerator
{
	private const string AttributeName = "AdventOfCode.Solutions.Core.GenerateParsableAttribute";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Register syntax receiver to find types with [GenerateParsable] attribute
		IncrementalValuesProvider<TypeDeclarationSyntax> typeDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
				transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
			.Where(static m => m is not null)!;

		// Combine with compilation
		IncrementalValueProvider<(Compilation, ImmutableArray<TypeDeclarationSyntax>)> compilationAndTypes
			= context.CompilationProvider.Combine(typeDeclarations.Collect());

		// Generate source
		context.RegisterSourceOutput(compilationAndTypes,
			static (spc, source) => Execute(source.Item1, source.Item2, spc));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };

	private static TypeDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		TypeDeclarationSyntax typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeListSyntax in typeDeclarationSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
			{
				if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				{
					continue;
				}

				INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
				string fullName = attributeContainingTypeSymbol.ToDisplayString();

				if (fullName == AttributeName)
				{
					return typeDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax> types, SourceProductionContext context)
	{
		if (types.IsDefaultOrEmpty)
		{
			return;
		}

		foreach (TypeDeclarationSyntax typeDeclaration in types.Distinct())
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			SemanticModel semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(typeDeclaration) is not INamedTypeSymbol typeSymbol)
			{
				continue;
			}

			string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
			string typeName = typeSymbol.Name;
			string typeKeyword = typeDeclaration.Keyword.Text; // "class", "record", "struct"

			// Get containing types (for nested types)
			List<(string Name, string Keyword)> containingTypes = [];
			INamedTypeSymbol? containingType = typeSymbol.ContainingType;
			while (containingType is not null)
			{
				string containingKeyword = containingType.TypeKind switch
				{
					TypeKind.Class => "partial class",
					TypeKind.Struct => "partial struct",
					_ => "partial class"
				};

				containingTypes.Insert(0, (containingType.Name, containingKeyword));
				containingType = containingType.ContainingType;
			}

			string source = GenerateSource(namespaceName, typeName, typeKeyword, containingTypes);

			// Use full type path for unique filename
			string fileName = containingTypes.Count > 0
				? $"{string.Join(".", containingTypes.Select(t => t.Name))}.{typeName}.g.cs"
				: $"{typeName}.g.cs";

			context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
		}
	}

	private static string GenerateSource(string namespaceName, string typeName, string typeKeyword, List<(string Name, string Keyword)> containingTypes)
	{
		// Build opening declarations for nested types
		StringBuilder containingTypesOpen = new();
		StringBuilder containingTypesClose = new();
		int baseIndent = 0;

		foreach ((string name, string keyword) in containingTypes)
		{
			_ = containingTypesOpen.AppendLine($"{GetIndent(baseIndent)}{keyword} {name}");
			_ = containingTypesOpen.AppendLine($"{GetIndent(baseIndent)}{{");
			_ = containingTypesClose.Insert(0, $"{GetIndent(baseIndent)}}}");
			_ = containingTypesOpen.AppendLine();
			baseIndent++;
		}

		string indent = GetIndent(baseIndent);

		return $$"""
			// <auto-generated/>
			#nullable enable

			using System.Diagnostics.CodeAnalysis;

			namespace {{namespaceName}};

			{{containingTypesOpen}}
			{{indent}}partial {{typeKeyword}} {{typeName}}
			{{indent}}{
			{{indent}}	public static {{typeName}} Parse(string s) => {{typeName}}.Parse(s, null);

			{{indent}}	public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out {{typeName}} result)
			{{indent}}	{
			{{indent}}		if (string.IsNullOrWhiteSpace(s))
			{{indent}}		{
			{{indent}}			result = default;
			{{indent}}			return false;
			{{indent}}		}

			{{indent}}		try
			{{indent}}		{
			{{indent}}			result = {{typeName}}.Parse(s, provider);
			{{indent}}			return true;
			{{indent}}		}
			{{indent}}		catch
			{{indent}}		{
			{{indent}}			result = default;
			{{indent}}			return false;
			{{indent}}		}
			{{indent}}	}
			{{indent}}}
			{{containingTypesClose}}
			""";
	}

	private static string GetIndent(int level) => new('\t', level);
}
