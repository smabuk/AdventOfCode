using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace AdventOfCode.SourceGenerators;

/// <summary>
/// Source generator that automatically generates visualiser boilerplate methods
/// for classes marked with [GenerateVisualiser] attribute.
/// </summary>
[Generator]
public class VisualiserGenerator : IIncrementalGenerator
{
	private const string AttributeName = "AdventOfCode.SourceGenerators.GenerateVisualiserAttribute";

	private const string AttributeSource = """
		// <auto-generated/>
		#nullable enable

		namespace AdventOfCode.SourceGenerators;

		/// <summary>
		/// Marks a class for automatic generation of visualiser boilerplate.
		/// The generator will create InitVisualiser method, _visualise field,
		/// and helper methods for grid and string visualisation.
		/// </summary>
		[global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
		internal sealed class GenerateVisualiserAttribute : global::System.Attribute
		{
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Generate the attribute itself so the generator is self-contained
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"GenerateVisualiserAttribute.g.cs",
			SourceText.From(AttributeSource, Encoding.UTF8)));

		// Register syntax receiver to find classes with [GenerateVisualiser] attribute
		IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
				transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
			.Where(static m => m is not null)!;

		// Combine with compilation
		IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
			= context.CompilationProvider.Combine(classDeclarations.Collect());

		// Generate source
		context.RegisterSourceOutput(compilationAndClasses,
			static (spc, source) => Execute(source.Item1, source.Item2, spc));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

	private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
			{
				if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				{
					continue;
				}

				INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
				string fullName = attributeContainingTypeSymbol.ToDisplayString();

				if (fullName == AttributeName)
				{
					return classDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
	{
		if (classes.IsDefaultOrEmpty)
		{
			return;
		}

		foreach (ClassDeclarationSyntax classDeclaration in classes.Distinct())
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
			{
				continue;
			}

			string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
			string className = classSymbol.Name;

			// Check if members already exist
			bool hasInitVisualiserMethod = HasInitVisualiserMethod(classSymbol);
			bool hasVisualiseField = HasVisualiseField(classSymbol);
			bool hasVisualiseGridMethod = HasVisualiseGridMethod(classSymbol);
			bool hasVisualiseGridWithMarkupMethod = HasVisualiseGridWithMarkupMethod(classSymbol);
			bool hasVisualiseStringMethod = HasVisualiseStringMethod(classSymbol);
			bool hasVisualiseStringsMethod = HasVisualiseStringsMethod(classSymbol);

			// Skip generation if all members already exist
			if (hasInitVisualiserMethod && hasVisualiseField && hasVisualiseGridMethod && hasVisualiseStringMethod && hasVisualiseStringsMethod)
			{
				continue;
			}

			string source = GenerateSource(
				namespaceName,
				className,
				!hasInitVisualiserMethod,
				!hasVisualiseField,
				!hasVisualiseGridMethod,
				!hasVisualiseGridWithMarkupMethod,
				!hasVisualiseStringMethod,
				!hasVisualiseStringsMethod);

			context.AddSource($"{className}.Visualiser.g.cs", SourceText.From(source, Encoding.UTF8));
		}
	}

	private static string GenerateSource(
		string namespaceName,
		string className,
		bool generateInitVisualiser,
		bool generateVisualiseField,
		bool generateVisualiseGrid,
		bool generateVisualiseGridWithMarkup,
		bool generateVisualiseString,
		bool generateVisualiseStrings)
	{
		string initVisualiserMethod = generateInitVisualiser
			? """
					public static void Visualiser(Action<string[], bool>? visualise) => _visualise = visualise;
				"""
			: "";

		string visualiseField = generateVisualiseField
			? """

					private static Action<string[], bool>? _visualise = null;
				"""
			: "";

		string visualiseGridMethod = generateVisualiseGrid
			? """

					/// <summary>
					/// Visualises a 2D char grid with a title.
					/// </summary>
					protected static void VisualiseGrid(Grid<char> grid, string title, bool clearScreen = false, params IEnumerable<(string Value, string Replacement)> replacements)
					{
						if (_visualise is not null)
						{
							string[] output = ["", title, .. grid.AsStrings(replacements)];
							_visualise?.Invoke(output, clearScreen);
						}
					}

					/// <summary>
					/// Visualises a 2D char grid with a title.
					/// </summary>
					protected static void VisualiseGrid(char[,] grid, string title, bool clearScreen = false, params IEnumerable<(string Value, string Replacement)> replacements)
					{
						if (_visualise is not null)
						{
							string[] output = ["", title, .. grid.AsStrings(replacements)];
							_visualise?.Invoke(output, clearScreen);
						}
					}
				"""
			: "";

		string visualiseGridWithMarkupMethod = generateVisualiseGridWithMarkup
			? """

					/// <summary>
					/// Displays the specified character grid with optional markup applied to selected items, using the configured
					/// visualisation mechanism.
					/// </summary>
					/// <remarks>If the configured visualisation mechanism supports markup, the specified items in the grid will be
					/// displayed using the provided colours. Otherwise, the grid is displayed without markup. This method has no effect if
					/// no visualisation mechanism is configured.</remarks>
					/// <param name="grid">The grid of characters to be visualised.</param>
					/// <param name="title">The title to display above the grid.</param>
					/// <param name="clearScreen">true to clear the screen before displaying the grid; otherwise, false.</param>
					/// <param name="markups">A list of tuples specifying which characters in the grid should be highlighted and the colour to use for each. If
					/// the visualisation mechanism does not support markup, this parameter is ignored.</param>
					protected static void VisualiseGridWithMarkup(Grid<char> grid, string title, bool clearScreen = false, params IEnumerable<(string Item, string Replacement)> replacements)
					{
						if (_visualise is not null) {
							replacements = _visualise.IsCapableOfMarkup()
								? [.. replacements.Select(m => (m.Replacement is ['[', .., ']'] ? ($"{m.Item}", $"{m.Replacement}{m.Item}[/]") : m))]
								: [.. replacements.Where(m => m.Replacement is not ['[', .., ']'])];

							string[] start = _visualise.IsCapableOfMarkup()
								? ["markup"]
								: [""];

							string[] output = [.. start, title, .. grid.AsStrings(replacements)];

							_visualise?.Invoke(output, clearScreen);
						}
					}

					/// <summary>
					/// Displays the specified character grid with optional markup applied to selected items, using the configured
					/// visualisation mechanism.
					/// </summary>
					/// <remarks>If the configured visualisation mechanism supports markup, the specified items in the grid will be
					/// displayed using the provided colours. Otherwise, the grid is displayed without markup. This method has no effect if
					/// no visualisation mechanism is configured.</remarks>
					/// <param name="grid">The grid of characters to be visualised.</param>
					/// <param name="title">The title to display above the grid.</param>
					/// <param name="clearScreen">true to clear the screen before displaying the grid; otherwise, false.</param>
					/// <param name="markups">A list of tuples specifying which characters in the grid should be highlighted and the colour to use for each. If
					/// the visualisation mechanism does not support markup, this parameter is ignored.</param>
					protected static void VisualiseGridWithMarkup(char[,] grid, string title, bool clearScreen = false, params IEnumerable<(string Item, string Replacement)> replacements)
					{
						if (_visualise is not null) {
							replacements = _visualise.IsCapableOfMarkup()
								? [.. replacements.Select(m => (m.Replacement is ['[', .. , ']'] ? ($"{m.Item}", $"{m.Replacement}{m.Item}[/]") : m))]
								: [.. replacements.Where(m => m.Replacement is not ['[', .., ']'])];

							string[] start = _visualise.IsCapableOfMarkup()
								? ["markup"]
								: [""];

							string[] output = [.. start, title, .. grid.AsStrings(replacements)];

							_visualise?.Invoke(output, clearScreen);
						}
					}
				"""
			: "";

		string visualiseStringMethod = generateVisualiseString
			? """

					/// <summary>
					/// Visualises a collection of strings with a title.
					/// </summary>
					protected static void VisualiseString(string stringToSend)
					{
						if (_visualise is not null)
						{
							string[] output = [stringToSend];
							_visualise?.Invoke(output, false);
						}
					}

					/// <summary>
					/// Visualises a collection of strings with a title.
					/// </summary>
					protected static void VisualiseStringWithMarkup(string stringToSend, params IEnumerable<(string Item, string Replacement)> replacements)
					{
						if (_visualise is not null)
						{
							replacements = _visualise.IsCapableOfMarkup()
								? [.. replacements.Select(m => (m.Replacement is ['[', .. , ']'] ? ($"{m.Item}", $"{m.Replacement}{m.Item}[/]") : m))]
								: [.. replacements.Where(m => m.Replacement is not ['[', .., ']'])];

							string processedString = stringToSend;
							foreach ((string item, string replacement) in replacements)
							{
								processedString = processedString.Replace(item, replacement);
							}

							if (_visualise.IsCapableOfMarkup())
							{
								_visualise?.Invoke(["markup", processedString], false);
							} else {
								processedString = System.Text.RegularExpressions.Regex.Replace(processedString, @"\[[^\]]+\]([^\[]*)\[/\]", "$1");
								_visualise?.Invoke([processedString], false);
							}
						}
					}
				"""
			: "";

		string visualiseStringsMethod = generateVisualiseStrings
			? """

					/// <summary>
					/// Visualises a collection of strings with a title.
					/// </summary>
					protected static void VisualiseStrings(IEnumerable<string> strings, string? title = null)
					{
						if (_visualise is not null)
						{
							string[] output = ["", title ?? "", .. strings];
							_visualise?.Invoke(output, false);
						}
					}
				"""
			: "";

		return $$"""
			// <auto-generated/>
			#nullable enable

			namespace {{namespaceName}};

			partial class {{className}}
			{
			{{initVisualiserMethod}}
			{{visualiseField}}
			{{visualiseGridMethod}}
			{{visualiseGridWithMarkupMethod}}
			{{visualiseStringMethod}}
			{{visualiseStringsMethod}}
			}
			""";
	}

	private static bool HasInitVisualiserMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("InitVisualiser")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic && m.Parameters.Length == 1);
	}

	private static bool HasVisualiseField(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("_visualise")
			.OfType<IFieldSymbol>()
			.Any();
	}

	private static bool HasVisualiseGridMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseGrid")
			.OfType<IMethodSymbol>()
			.Any();
	}

	private static bool HasVisualiseGridWithMarkupMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseGrid")
			.OfType<IMethodSymbol>()
			.Any();
	}

	private static bool HasVisualiseStringMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseString")
			.OfType<IMethodSymbol>()
			.Any();
	}

	private static bool HasVisualiseStringsMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseStrings")
			.OfType<IMethodSymbol>()
			.Any();
	}
}
