using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace AdventOfCode.SourceGenerators;

/// <summary>
/// Source generator that automatically generates visualiser boilerplate methods
/// for classes marked with [GenerateVisualiser] attribute.
/// </summary>
[Generator]
public class VisualiserGenerator : IIncrementalGenerator
{
	private const string AttributeName = "AdventOfCode.SourceGenerators.GenerateVisualiserAttribute";

	private const string AttributeSource = """
		// <auto-generated/>
		#nullable enable

		namespace AdventOfCode.SourceGenerators;

		/// <summary>
		/// Marks a class for automatic generation of visualiser boilerplate.
		/// The generator will create InitVisualiser method, _visualise field,
		/// and helper methods for grid and string visualisation.
		/// </summary>
		[global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
		internal sealed class GenerateVisualiserAttribute : global::System.Attribute
		{
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Generate the attribute itself so the generator is self-contained
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"GenerateVisualiserAttribute.g.cs",
			SourceText.From(AttributeSource, Encoding.UTF8)));

		// Register syntax receiver to find classes with [GenerateVisualiser] attribute
		IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
				transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
			.Where(static m => m is not null)!;

		// Combine with compilation
		IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
			= context.CompilationProvider.Combine(classDeclarations.Collect());

		// Generate source
		context.RegisterSourceOutput(compilationAndClasses,
			static (spc, source) => Execute(source.Item1, source.Item2, spc));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

	private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
			{
				if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				{
					continue;
				}

				INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
				string fullName = attributeContainingTypeSymbol.ToDisplayString();

				if (fullName == AttributeName)
				{
					return classDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
	{
		if (classes.IsDefaultOrEmpty)
		{
			return;
		}

		foreach (ClassDeclarationSyntax classDeclaration in classes.Distinct())
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
			{
				continue;
			}

			string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
			string className = classSymbol.Name;

			// Check if members already exist
			bool hasInitVisualiserMethod = HasInitVisualiserMethod(classSymbol);
			bool hasVisualiseField = HasVisualiseField(classSymbol);
			bool hasVisualiseGridMethod = HasVisualiseGridMethod(classSymbol);
			bool hasVisualiseStringMethod = HasVisualiseStringMethod(classSymbol);
			bool hasVisualiseStringsMethod = HasVisualiseStringsMethod(classSymbol);

			// Skip generation if all members already exist
			if (hasInitVisualiserMethod && hasVisualiseField && hasVisualiseGridMethod && hasVisualiseStringMethod && hasVisualiseStringsMethod)
			{
				continue;
			}

			string source = GenerateSource(
				namespaceName,
				className,
				!hasInitVisualiserMethod,
				!hasVisualiseField,
				!hasVisualiseGridMethod,
				!hasVisualiseStringMethod,
				!hasVisualiseStringsMethod);

			context.AddSource($"{className}.Visualiser.g.cs", SourceText.From(source, Encoding.UTF8));
		}
	}

	private static string GenerateSource(
		string namespaceName,
		string className,
		bool generateInitVisualiser,
		bool generateVisualiseField,
		bool generateVisualiseGrid,
		bool generateVisualiseString,
		bool generateVisualiseStrings)
	{
		string initVisualiserMethod = generateInitVisualiser
			? """

					[Visualiser]
					public static void InitVisualiser(Action<string[], bool>? visualise) => _visualise = visualise;
				"""
			: "";

		string visualiseField = generateVisualiseField
			? """

					private static Action<string[], bool>? _visualise = null;
				"""
			: "";

		string visualiseGridMethod = generateVisualiseGrid
			? """

					/// <summary>
					/// Visualises a 2D char grid with a title.
					/// </summary>
					protected static void VisualiseGrid(char[,] grid, string title)
					{
						if (_visualise is not null)
						{
							string[] output = ["", title, .. grid.AsStrings()];
							_ = Task.Run(() => _visualise?.Invoke(output, false));
						}
					}
				"""
			: "";

		string visualiseStringMethod = generateVisualiseString
			? """

					/// <summary>
					/// Visualises a collection of strings with a title.
					/// </summary>
					protected static void VisualiseString(string stringToSend)
					{
						if (_visualise is not null)
						{
							string[] output = [stringToSend];
							_ = Task.Run(() => _visualise?.Invoke(output, false));
						}
					}
				"""
			: "";

		string visualiseStringsMethod = generateVisualiseStrings
			? """

					/// <summary>
					/// Visualises a collection of strings with a title.
					/// </summary>
					protected static void VisualiseStrings(IEnumerable<string> strings, string? title = null)
					{
						if (_visualise is not null)
						{
							string[] output = ["", title ?? "", .. strings];
							_ = Task.Run(() => _visualise?.Invoke(output, false));
						}
					}
				"""
			: "";

		return $$"""
			// <auto-generated/>
			#nullable enable

			namespace {{namespaceName}};

			partial class {{className}}
			{
			{{initVisualiserMethod}}
			{{visualiseField}}
			{{visualiseGridMethod}}
			{{visualiseStringMethod}}
			{{visualiseStringsMethod}}
			}
			""";
	}

	private static bool HasInitVisualiserMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("InitVisualiser")
			.OfType<IMethodSymbol>()
			.Any(m => m.IsStatic && m.Parameters.Length == 1);
	}

	private static bool HasVisualiseField(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("_visualise")
			.OfType<IFieldSymbol>()
			.Any();
	}

	private static bool HasVisualiseGridMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseGrid")
			.OfType<IMethodSymbol>()
			.Any();
	}

	private static bool HasVisualiseStringMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseString")
			.OfType<IMethodSymbol>()
			.Any();
	}

	private static bool HasVisualiseStringsMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("VisualiseStrings")
			.OfType<IMethodSymbol>()
			.Any();
	}
}
