using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace AdventOfCode.SourceGenerators;

/// <summary>
/// Source generator that automatically generates test output helper boilerplate
/// for test classes marked with [SupportTestOutput] attribute.
/// </summary>
[Generator]
public class TestOutputGenerator : IIncrementalGenerator
{
	private const string AttributeName = "AdventOfCode.SourceGenerators.SupportTestOutputAttribute";

	private const string AttributeSource = """
		// <auto-generated/>
		#nullable enable

		namespace AdventOfCode.SourceGenerators;

		/// <summary>
		/// Marks a test class for automatic generation of ITestOutputHelper boilerplate.
		/// The generator will add the ITestOutputHelper parameter to the constructor
		/// and generate a Callback method for test output visualization.
		/// </summary>
		[global::System.AttributeUsage(global::System.AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
		internal sealed class SupportTestOutputAttribute : global::System.Attribute
		{
		}
		""";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Generate the attribute itself so the generator is self-contained
		context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
			"SupportTestOutputAttribute.g.cs",
			SourceText.From(AttributeSource, Encoding.UTF8)));

		// Register syntax receiver to find classes with [SupportTestOutput] attribute
		IncrementalValuesProvider<ClassDeclarationSyntax> classDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
				transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
			.Where(static m => m is not null)!;

		// Combine with compilation
		IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
			= context.CompilationProvider.Combine(classDeclarations.Collect());

		// Generate source
		context.RegisterSourceOutput(compilationAndClasses,
			static (spc, source) => Execute(source.Item1, source.Item2, spc));
	}

	private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
		=> node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

	private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
	{
		ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

		foreach (AttributeListSyntax attributeListSyntax in classDeclarationSyntax.AttributeLists)
		{
			foreach (AttributeSyntax attributeSyntax in attributeListSyntax.Attributes)
			{
				if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
				{
					continue;
				}

				INamedTypeSymbol attributeContainingTypeSymbol = attributeSymbol.ContainingType;
				string fullName = attributeContainingTypeSymbol.ToDisplayString();

				if (fullName == AttributeName)
				{
					return classDeclarationSyntax;
				}
			}
		}

		return null;
	}

	private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
	{
		if (classes.IsDefaultOrEmpty)
		{
			return;
		}

		foreach (ClassDeclarationSyntax classDeclaration in classes.Distinct())
		{
			context.CancellationToken.ThrowIfCancellationRequested();

			SemanticModel semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
			if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
			{
				continue;
			}

			string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
			string className = classSymbol.Name;

			// Check if constructor already has ITestOutputHelper parameter
			bool hasTestOutputHelperParameter = HasTestOutputHelperParameter(classSymbol);

			// Check if Callback method already exists
			bool hasCallbackMethod = HasCallbackMethod(classSymbol);

			// Skip generation if both already exist
			if (hasTestOutputHelperParameter && hasCallbackMethod)
			{
				continue;
			}

			string source = GenerateSource(
				namespaceName,
				className,
				!hasTestOutputHelperParameter,
				!hasCallbackMethod);

			context.AddSource($"{className}.TestOutput.g.cs", SourceText.From(source, Encoding.UTF8));
		}
	}

	private static string GenerateSource(
		string namespaceName,
		string className,
		bool generateConstructorParameter,
		bool generateCallbackMethod)
	{
		string constructorParameter = generateConstructorParameter
			? "(ITestOutputHelper _testOutputHelper)"
			: "";

		string callbackMethod = generateCallbackMethod
			? """

					private void Callback(string[] lines, bool _)
					{
						if (lines is null or [])
						{
							return;
						}

						_testOutputHelper.WriteLine(string.Join(Environment.NewLine, lines));
					}
				"""
			: "";

		string helperMethods = """

				/// <summary>
				/// Helper method that wraps SolutionRouter.SolveProblem with automatic Callback injection.
				/// </summary>
				protected string SolveProblem(int year, int day, int problemNo, string? input, params object[]? args)
					=> AdventOfCode.Solutions.SolutionRouter.SolveProblem(year, day, problemNo, input, new Action<string[], bool>(Callback), args);

				/// <summary>
				/// Helper method that wraps SolutionRouter.SolveProblem with automatic Callback injection.
				/// </summary>
				protected string SolveProblem(int year, int day, int problemNo, string[]? input, params object[]? args)
					=> AdventOfCode.Solutions.SolutionRouter.SolveProblem(year, day, problemNo, input, new Action<string[], bool>(Callback), args);
			""";

		return $$"""
			// <auto-generated/>
			#nullable enable

			namespace {{namespaceName}};

			partial class {{className}}{{constructorParameter}}
			{
			{{callbackMethod}}
			{{helperMethods}}
			}
			""";
	}

	private static bool HasTestOutputHelperParameter(INamedTypeSymbol classSymbol)
	{
		return classSymbol.Constructors
			.Where(c => !c.IsStatic)
			.SelectMany(constructor => constructor.Parameters)
			.Any(parameter => parameter.Type.Name == "ITestOutputHelper");
	}

	private static bool HasCallbackMethod(INamedTypeSymbol classSymbol)
	{
		return classSymbol.GetMembers("Callback")
			.OfType<IMethodSymbol>()
			.Any();
	}
}
